<!doctype html>
<html lang="uk">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>MAXMAL STUDIO — Interior AI (G-Wagen)</title>
<style>
  :root{
    --bg:#0b0c0e; --panel:#121316; --muted:#191b20;
    --text:#f2f2f2; --sub:#a6adbb;
    --accent:#ff7a00; --accent-2:#ffa45a; --stroke:#23252b;
    --blue:#3ea0ff;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  header{display:flex;align-items:center;gap:14px;padding:14px 18px;border-bottom:1px solid var(--stroke);background:linear-gradient(180deg,#0d0e11 0%,#0b0c0e 100%)}
  .logo{display:flex;align-items:center;gap:10px;font-weight:800;letter-spacing:.6px}
  .logo .mark{width:28px;height:28px;border-radius:7px;background:linear-gradient(135deg,var(--accent),var(--accent-2));display:grid;place-items:center;color:#0b0c0e;font-weight:900}
  .logo span{font-size:16px}
  .wrap{display:flex;gap:16px;padding:16px}
  .left,.right{background:var(--panel);border:1px solid var(--stroke);border-radius:14px;padding:12px}
  .left{flex:1;min-height:70vh;display:flex;flex-direction:column}
  .right{width:380px}
  .toolbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .group{display:flex;align-items:center;gap:8px;background:var(--muted);border:1px solid var(--stroke);padding:6px 10px;border-radius:10px}
  .btn{background:var(--accent);border:1px solid #e36e00;color:#0b0c0e;border-radius:10px;padding:8px 12px;cursor:pointer;font-weight:800}
  .btn.secondary{background:#1a1c21;color:#f1f1f1;border:1px solid var(--stroke)}
  .btn.ghost{background:transparent;border:1px dashed #3a3d47;color:#ffb783}
  .frame{position:relative;flex:1;margin-top:12px;background:#08090b;border:1px solid var(--stroke);border-radius:14px;overflow:hidden;display:flex;align-items:center;justify-content:center}
  .stack{position:relative;width:100%;height:100%}
  .stack canvas{position:absolute;inset:0;max-width:100%;max-height:100%;image-rendering:auto}
  #photo{z-index:1}
  #render{z-index:2; pointer-events:none}
  #mask{z-index:3; opacity:0} /* невидимий, але приймає кліки */
  .note{font-size:12px;color:var(--sub);margin-top:6px}

  .sec-title{font-size:12px;color:#f4b183;text-transform:uppercase;letter-spacing:.12em;margin:14px 0 8px}
  .row{display:flex;gap:8px;align-items:center;margin:8px 0}
  select,input[type="color"]{background:#0e1014;color:#f2f2f2;border:1px solid var(--stroke);border-radius:9px;padding:6px 8px}
  .small{font-size:12px;color:var(--sub)}
  .tooltog label{display:inline-flex;gap:6px;align-items:center;margin-right:8px;font-size:12px;color:#e9edf6}

  .swatches{display:grid;grid-template-columns:repeat(10,1fr);gap:6px}
  .sw{width:26px;height:26px;border-radius:6px;border:1px solid var(--stroke);cursor:pointer}
  .sw.selected{outline:2px solid var(--accent);outline-offset:2px}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}

  .switch{position:relative;width:44px;height:24px;background:#2a2d35;border:1px solid var(--stroke);border-radius:999px;cursor:pointer}
  .switch input{display:none}
  .knob{position:absolute;top:2px;left:2px;width:20px;height:20px;border-radius:50%;background:#aaa;transition:.18s}
  .switch input:checked + .knob{left:22px;background:linear-gradient(135deg,var(--accent),var(--accent-2))}

  .ok{color:#7cf29a;font-weight:700;display:none}

  /* Модалка: Строчки */
  .modal-back{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:50}
  .modal{width:min(92vw,560px);background:#0f1115;border:1px solid var(--stroke);border-radius:14px;padding:14px}
  .modal header{display:flex;justify-content:space-between;align-items:center;border:none;padding:0 0 10px 0}
  .modal h3{margin:0;font-size:16px}
  .chips{display:flex;gap:8px;flex-wrap:wrap}
  .chip{padding:6px 10px;border-radius:999px;border:1px solid var(--stroke);background:#15171c;cursor:pointer}
  .chip.active{border-color:var(--accent);box-shadow:0 0 0 2px rgba(255,122,0,.15) inset}

  /* Модалка: Авто */
  .auto-back{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:60}
  .auto{width:min(92vw,560px);background:#0f1115;border:1px solid var(--stroke);border-radius:14px;padding:14px}
  .auto header{display:flex;justify-content:space-between;align-items:center;border:none;padding:0 0 10px 0}
  .auto h3{margin:0;font-size:16px}
  .field{display:flex;gap:8px;align-items:center;margin:8px 0}
  .field input{flex:1;background:#0e1014;color:#f2f2f2;border:1px solid var(--stroke);border-radius:9px;padding:8px}
  .tip{font-size:12px;color:var(--sub)}
</style>

<!-- OpenCV -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
  window.cvReady=new Promise(res=>{
    if(window.cv && cv.getBuildInformation) return res();
    document.addEventListener('opencvready',res);
  });
</script>
</head>
<body>
<header>
  <div class="logo"><div class="mark">M</div><span>MAXMAL STUDIO — Interior AI</span></div>
</header>

<div class="wrap">
  <div class="left">
    <div class="toolbar">
      <div class="group"><label>Фото:</label><input id="file" type="file" accept="image/*"></div>
      <div class="group"><label>Авто:</label><select id="model"><option>G-Wagen</option></select></div>

      <button id="autoBtn" class="btn">Авто-розпізнавання</button>

      <div class="group tooltog">
        <label><input type="radio" name="tool" value="magic" checked> Клік (Magic)</label>
        <label><input type="radio" name="tool" value="pen"> Пензлик</label>
        <label><input type="radio" name="tool" value="eraser"> Гумка</label>
      </div>
      <div class="group"><label class="small">Кисть</label><input id="brush" type="range" min="6" max="80" value="30"></div>
      <div class="group"><label class="small">Толерантність</label><input id="tol" type="range" min="5" max="40" value="22"></div>
      <button id="refine" class="btn secondary">Уточнити маску</button>
      <button id="clear" class="btn ghost">Очистити</button>
      <div class="group"><label class="small"><input id="showMask" type="checkbox" checked> Показати маску</label></div>
    </div>

    <div class="frame">
      <div class="stack">
        <canvas id="photo"></canvas>
        <canvas id="render"></canvas>
        <canvas id="mask"></canvas>
      </div>
    </div>
    <div class="note">Зараз можна: вручну (Magic/Пензлик) або натиснути <b>Авто-розпізнавання</b> — зʼявляться контури елементів; клік по контуру підставить маску.</div>
  </div>

  <div class="right">
    <div class="sec-title">Колір</div>
    <div class="swatches" id="swatches"></div>
    <div class="row grid2">
      <div class="row"><span class="small">Будь-який колір</span></div>
      <input id="color" type="color" value="#d13c2f"/>
    </div>

    <div class="sec-title">Матеріал</div>
    <div class="row">
      <select id="material">
        <option value="leather" selected>Шкіра</option>
        <option value="alcantara">Алькантара</option>
        <option value="carbon">Карбон</option>
      </select>
    </div>

    <div class="sec-title">Перфорація</div>
    <div class="row">
      <label class="switch">
        <input id="perforated" type="checkbox">
        <span class="knob"></span>
      </label>
      <span class="small">увімкнути / вимкнути</span>
    </div>

    <div class="sec-title">Строчки</div>
    <div class="row">
      <button id="stitchesBtn" class="btn">Відкрити вікно строчок</button>
    </div>

    <div class="sec-title">Збереження</div>
    <div class="row">
      <button id="save" class="btn secondary">ОК (зберегти приклад)</button>
    </div>
    <div id="saved" class="ok">Збережено ✅</div>
  </div>
</div>

<!-- МОДАЛКА: СТРОЧКИ -->
<div class="modal-back" id="modalBack">
  <div class="modal">
    <header>
      <h3>Генерація строчок (демо)</h3>
      <button id="closeModal" class="btn secondary">Закрити</button>
    </header>
    <div class="sec-title">Стиль</div>
    <div class="chips" id="stitchStyles">
      <div class="chip active" data-style="diamonds">Ромби</div>
      <div class="chip" data-style="parallel">Паралельні</div>
      <div class="chip" data-style="waves">Хвилі</div>
    </div>
    <div class="row" style="margin-top:14px">
      <button id="genStitches" class="btn">Згенерувати (демо)</button>
    </div>
    <div class="note">У продакшені тут буде генерація строчок від AI (тільки в межах маски).</div>
  </div>
</div>

<!-- МОДАЛКА: АВТО -->
<div class="auto-back" id="autoBack">
  <div class="auto">
    <header>
      <h3>Авто-розпізнавання</h3>
      <button id="closeAuto" class="btn secondary">Закрити</button>
    </header>

    <div class="sec-title">Марка та модель</div>
    <div class="field">
      <label class="small">Марка</label>
      <input id="makeInput" value="Mercedes-Benz"/>
    </div>
    <div class="field">
      <label class="small">Модель</label>
      <input id="modelInput" value="G-Class (W463)"/>
    </div>
    <div class="tip">Це демо-визначення. У майбутній версії тут буде AI, який впізнає авто з фото і підтягне правильну модель.</div>

    <div class="row" style="margin-top:12px">
      <button id="runAuto" class="btn">Запустити розпізнавання елементів</button>
    </div>
  </div>
</div>

<script>
  // ===== Канваси =====
  const photo   = document.getElementById('photo');
  const render  = document.getElementById('render');
  const mask    = document.getElementById('mask');
  const pctx = photo.getContext('2d');
  const rctx = render.getContext('2d');
  const mctx = mask.getContext('2d');

  // ===== UI =====
  const file = document.getElementById('file');
  const toolRadios = [...document.querySelectorAll('input[name="tool"]')];
  const brush = document.getElementById('brush');
  const tol = document.getElementById('tol');
  const refineBtn = document.getElementById('refine');
  const clearBtn = document.getElementById('clear');
  const showMask = document.getElementById('showMask');

  const autoBtn = document.getElementById('autoBtn');
  const autoBack = document.getElementById('autoBack');
  const closeAuto = document.getElementById('closeAuto');
  const makeInput = document.getElementById('makeInput');
  const modelInput = document.getElementById('modelInput');
  const runAuto = document.getElementById('runAuto');

  const color = document.getElementById('color');
  const material = document.getElementById('material');
  const perforated = document.getElementById('perforated');

  const swatchesBox = document.getElementById('swatches');

  const saveBtn = document.getElementById('save');
  const saved = document.getElementById('saved');

  const stitchesBtn = document.getElementById('stitchesBtn');
  const modalBack = document.getElementById('modalBack');
  const closeModal = document.getElementById('closeModal');
  const stitchStyles = document.getElementById('stitchStyles');
  const genStitches = document.getElementById('genStitches');

  // ===== Стан =====
  let hasImage=false, drawing=false, curTool='magic';
  let overlayStitches = null; // канвас зі строчками
  let autoRegions = [];       // масив {maskCanvas, contourPath} для автосегментації

  function resizeCanvases(w,h){
    [photo, render, mask].forEach(c=>{ c.width=w; c.height=h; });
    mctx.clearRect(0,0,w,h); rctx.clearRect(0,0,w,h);
    autoRegions = [];
  }

  // ===== Завантаж фото =====
  file.addEventListener('change', e=>{
    const f=e.target.files[0]; if(!f) return;
    const url=URL.createObjectURL(f);
    const img=new Image();
    img.onload=()=>{
      let w=img.naturalWidth, h=img.naturalHeight;
      const ms=1400, m=Math.max(w,h);
      if(m>ms){ const s=ms/m; w=Math.round(w*s); h=Math.round(h*s); }
      resizeCanvases(w,h);
      pctx.drawImage(img,0,0,w,h);
      hasImage=true;
      overlayStitches = null;
      drawPreview();
    };
    img.src=url;
  });

  // ===== Інструменти =====
  toolRadios.forEach(r=> r.addEventListener('change', ()=>{ curTool = toolRadios.find(x=>x.checked).value; }));

  function getPos(evt, canvas){
    const rect=canvas.getBoundingClientRect();
    const sx=canvas.width/rect.width, sy=canvas.height/rect.height;
    return { x:Math.round((evt.clientX-rect.left)*sx), y:Math.round((evt.clientY-rect.top)*sy) };
  }

  mask.addEventListener('pointerdown', e=>{
    if(!hasImage) return;
    const pos=getPos(e, mask);

    // Якщо є автосегментація — клік по контурі/ділянці = підставити ту маску
    if(autoRegions.length){
      const pick = pickAutoRegionAt(pos.x, pos.y);
      if(pick){ applyRegionToMask(pick.maskCanvas); drawPreview(); return; }
    }

    if(curTool==='magic'){ magicFillAt(pos.x,pos.y,parseInt(tol.value,10)).then(drawPreview); return; }
    drawing=true; drawDot(pos.x,pos.y); drawPreview();
  });
  mask.addEventListener('pointermove', e=>{
    if(!drawing||!hasImage) return;
    const pos=getPos(e, mask); drawDot(pos.x,pos.y); drawPreview();
  });
  ['pointerup','pointerleave','pointercancel'].forEach(ev=> mask.addEventListener(ev, ()=>{ drawing=false; }));

  function drawDot(x,y){
    const b=parseInt(brush.value,10);
    mctx.globalCompositeOperation=(curTool==='eraser')?'destination-out':'source-over';
    mctx.fillStyle='rgba(255,255,255,1)';
    mctx.beginPath(); mctx.arc(x,y,b/2,0,Math.PI*2); mctx.fill();
    mctx.globalCompositeOperation='source-over';
  }

  clearBtn.addEventListener('click', ()=>{ mctx.clearRect(0,0,mask.width,mask.height); overlayStitches=null; drawPreview(); });
  showMask.addEventListener('change', drawPreview);

  // ===== Magic Fill (Lab + ΔE) =====
  async function magicFillAt(x, y, tolerance = 22) {
    await window.cvReady;
    const w = photo.width, h = photo.height;
    let src = cv.imread(photo); cv.cvtColor(src, src, cv.COLOR_RGBA2RGB);
    let lab = new cv.Mat(); cv.cvtColor(src, lab, cv.COLOR_RGB2Lab);

    const r0 = Math.max(0, y-2), r1 = Math.min(h-1, y+2);
    const c0 = Math.max(0, x-2), c1 = Math.min(w-1, x+2);
    let Lm=0, am=0, bm=0, n=0;
    for(let r=r0;r<=r1;r++) for(let c=c0;c<=c1;c++){ const p=lab.ucharPtr(r,c); Lm+=p[0]; am+=p[1]; bm+=p[2]; n++; }
    Lm/=n; am/=n; bm/=n;

    const deltaE = Math.max(6, Math.min(40, tolerance*1.2));
    let maskLab = new cv.Mat.zeros(h,w,cv.CV_8UC1);
    for(let r=0;r<h;r++){
      for(let c=0;c<w;c++){
        const p=lab.ucharPtr(r,c);
        const dL=p[0]-Lm, da=p[1]-am, db=p[2]-bm;
        const dE=Math.sqrt(dL*dL+da*da+db*db);
        maskLab.ucharPtr(r,c)[0] = dE<=deltaE ? 255 : 0;
      }
    }
    const k = cv.Mat.ones(3,3,cv.CV_8U);
    cv.morphologyEx(maskLab,maskLab,cv.MORPH_OPEN,k);
    cv.morphologyEx(maskLab,maskLab,cv.MORPH_CLOSE,k);

    const mImg=mctx.getImageData(0,0,w,h);
    for(let i=0,j=0;j<w*h;i+=4,j++){
      const add=maskLab.data[j];
      if(add){ mImg.data[i]=255; mImg.data[i+1]=255; mImg.data[i+2]=255; mImg.data[i+3]=255; }
    }
    mctx.putImageData(mImg,0,0);

    src.delete(); lab.delete(); maskLab.delete(); k.delete();
  }

  // ===== GrabCut refine =====
  async function refineMaskClient(){
    await window.cvReady;
    const w=photo.width,h=photo.height;
    const src=cv.imread(photo); cv.cvtColor(src,src,cv.COLOR_RGBA2RGB);
    const maskImg=mctx.getImageData(0,0,w,h);
    const gcMask=new cv.Mat(h,w,cv.CV_8UC1);
    for(let i=0,j=0;j<w*h;i+=4,j++){ const a=maskImg.data[i+3]; gcMask.data[j]=a>0?3:2; }
    const bg=new cv.Mat(), fg=new cv.Mat(); const rect=new cv.Rect(0,0,w,h);
    cv.grabCut(src,gcMask,rect,bg,fg,5,cv.GC_INIT_WITH_MASK);
    const result=new cv.Mat(h,w,cv.CV_8UC1);
    for(let j=0;j<w*h;j++){ const v=gcMask.data[j]; result.data[j]=(v===1||v===3)?255:0; }
    const out=mctx.createImageData(w,h);
    for(let i=0,j=0;j<w*h;i+=4,j++){ out.data[i]=255; out.data[i+1]=255; out.data[i+2]=255; out.data[i+3]=result.data[j]; }
    mctx.putImageData(out,0,0);
    src.delete(); gcMask.delete(); bg.delete(); fg.delete(); result.delete();
    drawPreview();
  }
  document.getElementById('refine').addEventListener('click', ()=>{ if(hasImage) refineMaskClient(); });

  // ===== Палетка 20 кольорів =====
  const PALETTE = [
   "#000000","#2d2d2d","#585858","#8f8f8f","#ffffff",
   "#ff7a00","#ffb000","#ffd400","#ff3b3b","#d13c2f",
   "#a61e4d","#8a2be2","#2f6bd1","#3ea0ff","#27c5c3",
   "#2fbf71","#88d840","#c6ff3d","#8b5a2b","#c49a6c"
  ];
  function buildSwatches(){
    PALETTE.forEach(hex=>{
      const d=document.createElement('div');
      d.className='sw'; d.style.background=hex;
      d.addEventListener('click',()=>{
        document.querySelectorAll('.sw').forEach(s=>s.classList.remove('selected'));
        d.classList.add('selected');
        color.value = hex; drawPreview();
      });
      swatchesBox.appendChild(d);
    });
    const idx = PALETTE.indexOf("#ff7a00");
    if(idx>=0) swatchesBox.children[idx].classList.add('selected');
  }
  buildSwatches();

  // ===== Матеріали (текстури) =====
  function makeMaterialTexture(w,h, type){
    const c=document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d');
    if(type==='leather'){
      const img=ctx.createImageData(w,h);
      for(let i=0;i<img.data.length;i+=4){ const n = 128 + ((Math.random()*50)|0);
        img.data[i]=n; img.data[i+1]=n; img.data[i+2]=n; img.data[i+3]=28; }
      ctx.putImageData(img,0,0);
    }else if(type==='alcantara'){
      const img=ctx.createImageData(w,h);
      for(let i=0;i<img.data.length;i+=4){ const n = 120 + ((Math.random()*25)|0);
        img.data[i]=n; img.data[i+1]=n; img.data[i+2]=n; img.data[i+3]=35; }
      ctx.putImageData(img,0,0);
    }else if(type==='carbon'){
      ctx.fillStyle="rgba(255,255,255,0.18)";
      for(let i=-h;i<w+h;i+=14){ ctx.fillRect(i,0,7,h); }
      ctx.globalCompositeOperation="multiply";
      ctx.fillStyle="rgba(0,0,0,0.85)"; ctx.fillRect(0,0,w,h);
      ctx.globalCompositeOperation="source-over";
    }
    return c;
  }

  // ===== Перфорація (on/off) =====
  function makePerforation(w,h){
    const c=document.createElement('canvas'); c.width=w;c.height=h;const ctx=c.getContext('2d');
    const step=18; ctx.fillStyle="rgba(0,0,0,0.65)";
    for(let y=step/2;y<h;y+=step) for(let x=step/2;x<w;x+=step){
      ctx.beginPath(); ctx.arc(x,y,2,0,Math.PI*2); ctx.fill();
    }
    return c;
  }

  // ===== Строчки (модалка) =====
  function makeStitches(w,h, style){
    const c=document.createElement('canvas'); c.width=w;c.height=h; const ctx=c.getContext('2d');
    if(style==='diamonds'){
      const step=40; ctx.lineWidth=1;
      ctx.strokeStyle="rgba(255,255,255,0.38)";
      for(let i=-h;i<w+h;i+=step){ ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i-h,h); ctx.stroke(); }
      ctx.strokeStyle="rgba(0,0,0,0.45)";
      for(let i=0;i<w+h;i+=step){ ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i+h,h); ctx.stroke(); }
    }else if(style==='parallel'){
      const step=28; ctx.lineWidth=1.2;
      ctx.strokeStyle="rgba(255,255,255,0.38)";
      for(let y=12;y<h;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
      ctx.strokeStyle="rgba(0,0,0,0.38)";
      for(let y=12;y<h;y+=step){ ctx.beginPath(); ctx.moveTo(0,y+3); ctx.lineTo(w,y+3); ctx.stroke(); }
    }else if(style==='waves'){
      ctx.strokeStyle="rgba(255,255,255,0.35)"; ctx.lineWidth=1.2;
      for(let y=20;y<h;y+=36){
        ctx.beginPath();
        for(let x=0;x<=w;x+=8){
          const yy = y + Math.sin(x/28)*6;
          if(x===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
        }
        ctx.stroke();
      }
      ctx.strokeStyle="rgba(0,0,0,0.35)";
      for(let y=20;y<h;y+=36){
        ctx.beginPath();
        for(let x=0;x<=w;x+=8){
          const yy = y + 3 + Math.sin(x/28)*6;
          if(x===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
        }
        ctx.stroke();
      }
    }
    return c;
  }

  // Модалки
  stitchesBtn.addEventListener('click', ()=>{ modalBack.style.display='flex'; });
  closeModal.addEventListener('click', ()=>{ modalBack.style.display='none'; });
  stitchStyles.addEventListener('click', (e)=>{
    const chip = e.target.closest('.chip'); if(!chip) return;
    [...stitchStyles.children].forEach(c=>c.classList.remove('active'));
    chip.classList.add('active');
  });
  genStitches.addEventListener('click', ()=>{
    if(!hasImage) return;
    const active = stitchStyles.querySelector('.chip.active')?.dataset.style || 'diamonds';
    overlayStitches = makeStitches(render.width, render.height, active);
    modalBack.style.display='none';
    drawPreview();
  });

  autoBtn.addEventListener('click', ()=>{ if(!hasImage) return; autoBack.style.display='flex'; });
  closeAuto.addEventListener('click', ()=>{ autoBack.style.display='none'; });

  runAuto.addEventListener('click', async ()=>{
    if(!hasImage) return;
    autoBack.style.display='none';
    await runAutoSegmentation(); // запустити автосегментацію
    drawPreview();
  });

  // ====== АВТОСЕГМЕНТАЦІЯ (демо на k-means + контури) ======
  async function runAutoSegmentation(){
    await window.cvReady;
    const W = photo.width, H = photo.height;

    // 1) Зменшуємо фото для швидкості
    const targetW = 320;
    const scale = targetW / W;
    const targetH = Math.max(1, Math.round(H * scale));

    let srcFull = cv.imread(photo); cv.cvtColor(srcFull, srcFull, cv.COLOR_RGBA2RGB);
    let src = new cv.Mat(); cv.resize(srcFull, src, new cv.Size(targetW, targetH), 0, 0, cv.INTER_AREA);

    // 2) у Lab
    let lab = new cv.Mat(); cv.cvtColor(src, lab, cv.COLOR_RGB2Lab);

    // 3) k-means по кольору (K=5)
    const samples = lab.reshape(1, targetW*targetH); // Nx3
    samples.convertTo(samples, cv.CV_32F);
    const K = 5;
    const criteria = new cv.TermCriteria(cv.TermCriteria_EPS + cv.TermCriteria_MAX_ITER, 10, 1.0);
    const labels = new cv.Mat();
    const centers = new cv.Mat();
    cv.kmeans(samples, K, labels, criteria, 2, cv.KMEANS_PP_CENTERS, centers);

    // 4) Будуємо маску для кожного кластера, масштабуємо назад до оригіналу і чистимо
    autoRegions = [];
    for(let k=0; k<K; k++){
      let maskSmall = new cv.Mat.zeros(targetH, targetW, cv.CV_8UC1);
      for(let i=0;i<labels.rows;i++){
        if(labels.intAt(i,0) === k){
          const r = Math.floor(i/targetW);
          const c = i % targetW;
          maskSmall.ucharPtr(r,c)[0] = 255;
        }
      }
      // морфологія
      const k3 = cv.Mat.ones(3,3,cv.CV_8U);
      cv.morphologyEx(maskSmall, maskSmall, cv.MORPH_OPEN, k3);
      cv.morphologyEx(maskSmall, maskSmall, cv.MORPH_CLOSE, k3);

      // апскейл до повного
      let maskBig = new cv.Mat();
      cv.resize(maskSmall, maskBig, new cv.Size(W,H), 0, 0, cv.INTER_NEAREST);

      // фільтр по площі
      const area = cv.countNonZero(maskBig);
      if(area < (W*H*0.01)){ // відсікаємо надто малі
        maskSmall.delete(); k3.delete(); maskBig.delete(); continue;
      }

      // знайдемо контур для підсвічування
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(maskBig, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      if(contours.size()===0){
        maskSmall.delete(); k3.delete(); maskBig.delete(); contours.delete(); hierarchy.delete();
        continue;
      }

      // збережемо маску як canvas
      const mCanvas = document.createElement('canvas'); mCanvas.width=W; mCanvas.height=H;
      const mCtx = mCanvas.getContext('2d');
      const id = mCtx.createImageData(W,H);
      for(let y=0;y<H;y++){
        for(let x=0;x<W;x++){
          const idx = (y*W + x)*4;
          const v = maskBig.ucharPtr(y,x)[0];
          id.data[idx]=255; id.data[idx+1]=255; id.data[idx+2]=255; id.data[idx+3]=v>0?255:0;
        }
      }
      mCtx.putImageData(id,0,0);

      // створимо Path2D з найбільшого контуру
      let maxA=0, best=null;
      for(let ci=0; ci<contours.size(); ci++){
        const cnt = contours.get(ci);
        const a = cv.contourArea(cnt);
        if(a>maxA){ maxA=a; best=cnt; }
      }
      let path = null;
      if(best){
        path = new Path2D();
        for(let i=0;i<best.data32S.length;i+=2){
          const x = best.data32S[i], y = best.data32S[i+1];
          if(i===0) path.moveTo(x,y); else path.lineTo(x,y);
        }
        path.closePath();
      }

      autoRegions.push({ maskCanvas: mCanvas, contourPath: path });

      maskSmall.delete(); k3.delete(); maskBig.delete(); contours.delete(); hierarchy.delete();
    }

    // прибирання
    centers.delete(); labels.delete(); samples.delete(); lab.delete(); src.delete(); srcFull.delete();
  }

  // клік по автосегменту
  function pickAutoRegionAt(x,y){
    for(const r of autoRegions){
      if(!r.maskCanvas) continue;
      const m = r.maskCanvas.getContext('2d').getImageData(x,y,1,1);
      if(m.data[3] > 0) return r;
    }
    return null;
  }

  function applyRegionToMask(regionCanvas){
    const w=mask.width, h=mask.height;
    const src = regionCanvas.getContext('2d').getImageData(0,0,w,h);
    const out = mctx.createImageData(w,h);
    for(let i=0;i<src.data.length;i+=4){
      const a = src.data[i+3];
      out.data[i]=255; out.data[i+1]=255; out.data[i+2]=255; out.data[i+3]=a>0?255:0;
    }
    mctx.putImageData(out,0,0);
  }

  // ===== Рендерінг накладки =====
  function hexToRgb(hex){ const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return m?{r:parseInt(m[1],16),g:parseInt(m[2],16),b:parseInt(m[3],16)}:{r:200,g:0,b:0} }

  function clipByAlphaAndDraw(maskImgData, sourceCanvas, destCtx){
    const w=sourceCanvas.width, h=sourceCanvas.height;
    const tmp=document.createElement('canvas'); tmp.width=w; tmp.height=h;
    const tctx=tmp.getContext('2d');
    tctx.drawImage(sourceCanvas,0,0);
    const alphaCanvas=document.createElement('canvas'); alphaCanvas.width=w; alphaCanvas.height=h;
    const actx=alphaCanvas.getContext('2d');
    const aimg=actx.createImageData(w,h);
    for(let i=0;i<aimg.data.length;i+=4){
      aimg.data[i]=0; aimg.data[i+1]=0; aimg.data[i+2]=0; aimg.data[i+3]=maskImgData.data[i+3];
    }
    actx.putImageData(aimg,0,0);
    tctx.globalCompositeOperation="destination-in";
    tctx.drawImage(alphaCanvas,0,0);
    tctx.globalCompositeOperation="source-over";
    destCtx.drawImage(tmp,0,0);
  }

  function makeStitches(w,h, style){
    const c=document.createElement('canvas'); c.width=w;c.height=h; const ctx=c.getContext('2d');
    if(style==='diamonds'){
      const step=40; ctx.lineWidth=1;
      ctx.strokeStyle="rgba(255,255,255,0.38)";
      for(let i=-h;i<w+h;i+=step){ ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i-h,h); ctx.stroke(); }
      ctx.strokeStyle="rgba(0,0,0,0.45)";
      for(let i=0;i<w+h;i+=step){ ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i+h,h); ctx.stroke(); }
    }else if(style==='parallel'){
      const step=28; ctx.lineWidth=1.2;
      ctx.strokeStyle="rgba(255,255,255,0.38)";
      for(let y=12;y<h;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
      ctx.strokeStyle="rgba(0,0,0,0.38)";
      for(let y=12;y<h;y+=step){ ctx.beginPath(); ctx.moveTo(0,y+3); ctx.lineTo(w,y+3); ctx.stroke(); }
    }else if(style==='waves'){
      ctx.strokeStyle="rgba(255,255,255,0.35)"; ctx.lineWidth=1.2;
      for(let y=20;y<h;y+=36){
        ctx.beginPath();
        for(let x=0;x<=w;x+=8){
          const yy = y + Math.sin(x/28)*6;
          if(x===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
        }
        ctx.stroke();
      }
      ctx.strokeStyle="rgba(0,0,0,0.35)";
      for(let y=20;y<h;y+=36){
        ctx.beginPath();
        for(let x=0;x<=w;x+=8){
          const yy = y + 3 + Math.sin(x/28)*6;
          if(x===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
        }
        ctx.stroke();
      }
    }
    return c;
  }

  function drawPreview(){
    if(!hasImage){ rctx.clearRect(0,0,render.width,render.height); return; }
    const w=render.width,h=render.height;
    rctx.clearRect(0,0,w,h);

    const base=pctx.getImageData(0,0,w,h);
    const mimg=mctx.getImageData(0,0,w,h);
    const overlay=rctx.createImageData(w,h);

    const col=hexToRgb(color.value);
    const mixK=0.65;

    // 1) колір у межах маски
    for(let i=0;i<overlay.data.length;i+=4){
      const a=mimg.data[i+3];
      if(a>0){
        const r0=base.data[i], g0=base.data[i+1], b0=base.data[i+2];
        overlay.data[i]   = Math.round((1-mixK)*r0 + mixK*col.r);
        overlay.data[i+1] = Math.round((1-mixK)*g0 + mixK*col.g);
        overlay.data[i+2] = Math.round((1-mixK)*b0 + mixK*col.b);
        overlay.data[i+3] = 255;
      }else{
        overlay.data[i+3] = 0;
      }
    }
    rctx.putImageData(overlay,0,0);

    // 2) матеріал
    const tex=makeMaterialTexture(w,h, material.value);
    rctx.globalAlpha=0.18;
    clipByAlphaAndDraw(mimg, tex, rctx);
    rctx.globalAlpha=1;

    // 3) перфорація
    if(perforated.checked){
      const perf=makePerforation(w,h);
      clipByAlphaAndDraw(mimg, perf, rctx);
    }

    // 4) строчки (якщо згенеровані)
    if(overlayStitches){ clipByAlphaAndDraw(mimg, overlayStitches, rctx); }

    // 5) синя підсвітка вручну
    if(showMask.checked){
      const blue=rctx.createImageData(w,h);
      for(let i=0;i<blue.data.length;i+=4){
        blue.data[i]=40; blue.data[i+1]=110; blue.data[i+2]=255;
        blue.data[i+3]=Math.round(mimg.data[i+3]*0.32);
      }
      rctx.putImageData(blue,0,0);
    }

    // 6) якщо є авто-регіони — намалюємо їх контури (пунктиром)
    if(autoRegions.length){
      rctx.save();
      rctx.lineWidth = 2;
      rctx.setLineDash([8,6]);
      rctx.strokeStyle = "rgba(255,122,0,0.9)";
      for(const r of autoRegions){
        if(r.contourPath) rctx.stroke(r.contourPath);
      }
      rctx.restore();
    }
  }

  // Живе прев’ю
  [color, material, perforated].forEach(el=>{
    el.addEventListener('input', drawPreview);
    el.addEventListener('change', drawPreview);
  });

  saveBtn.addEventListener('click', ()=>{ saved.style.display='inline'; setTimeout(()=>saved.style.display='none',1800); });

  // ===== Ініт =====
  (function init(){ resizeCanvases(1200,720); })();
</script>
</body>
</html>
