<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>G-Wagen Interior Tool (MVP)</title>
  <style>
    :root{--bg:#0f1115;--panel:#171a21;--text:#e6e6e6;--sub:#9aa4b2;--accent:#4da3ff}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial}
    header{padding:14px 18px;border-bottom:1px solid #252a33}
    header h1{font-size:16px;margin:0;font-weight:600}
    .wrap{display:flex;gap:16px;padding:16px}
    .left,.right{background:var(--panel);border:1px solid #222833;border-radius:12px;padding:12px}
    .left{flex:1;min-height:70vh;display:flex;flex-direction:column}
    .right{width:360px}
    .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .group{display:flex;align-items:center;gap:8px;background:#12151b;border:1px solid #222833;padding:6px 8px;border-radius:10px}
    .btn{background:#1e2430;border:1px solid #2a3240;color:#e9eef6;border-radius:10px;padding:8px 12px;cursor:pointer;font-weight:600}
    .btn:hover{border-color:#3a465a}.btn.accent{background:var(--accent);border-color:#67b0ff;color:#081321}
    .btn.ghost{background:transparent;border:1px dashed #3a465a;color:#bcd2ff}
    .frame{position:relative;flex:1;margin-top:12px;background:#0a0d12;border:1px solid #222833;border-radius:12px;overflow:hidden;display:flex;align-items:center;justify-content:center}
    /* Стек канвасів */
    .stack{position:relative;width:100%;height:100%}
    .stack canvas{position:absolute;inset:0;max-width:100%;max-height:100%;image-rendering:auto}
    #photo{z-index:1}
    #render{z-index:2; pointer-events:none;}  /* тільки накладка */
    #mask{z-index:3; opacity:0; }              /* приймає кліки, але НЕ видно білий малюнок */
    .note{font-size:12px;color:#94a3b8;margin-top:6px}
    .row{display:flex;gap:8px;align-items:center;margin:8px 0}
    select,input[type="color"],input[type="range"]{background:#0f1320;color:#e6e6e6;border:1px solid #2a3240;border-radius:8px;padding:6px 8px}
    input[type="range"]{width:100%}
    .sec-title{font-size:12px;color:#9aa4b2;text-transform:uppercase;letter-spacing:.1em;margin:14px 0 8px}
    .small{font-size:12px;color:#aab4c3}.ok{color:#7cf29a;font-weight:600;display:none}
    .tooltog label{display:inline-flex;gap:6px;align-items:center;margin-right:8px;font-size:12px;color:#c7d2e1}
  </style>

  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script>
    window.cvReady = new Promise(res=>{
      if (window.cv && cv.getBuildInformation) return res();
      document.addEventListener('opencvready', res);
    });
  </script>
</head>
<body>
<header><h1>G-Wagen Interior Tool — логічне виділення + зміни тільки в масці</h1></header>

<div class="wrap">
  <div class="left">
    <div class="toolbar">
      <div class="group"><label>Фото:</label><input id="file" type="file" accept="image/*"></div>
      <div class="group"><label>Авто:</label><select><option>G-Wagen</option></select></div>
      <div class="group"><label>Деталь:</label>
        <select id="part">
          <option value="door_insert" selected>Дверна вставка</option>
          <option value="door_upper">Верх дверної карти</option>
          <option value="armrest">Підлокітник</option>
          <option value="door_lower">Нижня частина</option>
        </select>
      </div>
      <div class="group tooltog">
        <label><input type="radio" name="tool" value="magic" checked> Клік (Magic)</label>
        <label><input type="radio" name="tool" value="pen"> Пензлик</label>
        <label><input type="radio" name="tool" value="eraser"> Гумка</label>
      </div>
      <div class="group"><label class="small">Кисть</label><input id="brush" type="range" min="6" max="80" value="32"></div>
      <div class="group"><label class="small">Толерантність</label><input id="tol" type="range" min="5" max="40" value="14"></div>
      <button id="refine" class="btn">Уточнити маску (Auto)</button>
      <button id="clear" class="btn ghost">Очистити маску</button>
      <div class="group"><label><input id="showMask" type="checkbox" checked> Показати маску</label></div>
    </div>

    <div class="frame">
      <div class="stack">
        <canvas id="photo"></canvas>
        <canvas id="render"></canvas>
        <canvas id="mask"></canvas>
      </div>
    </div>
    <div class="note">1) Завантаж фото. 2) “Клік (Magic)” по деталі → зʼявиться маска. 3) Пензлик/Гумка підправ. 4) “Уточнити маску”. 5) Праворуч міняй колір/матеріал — прев’ю живе.</div>
  </div>

  <div class="right">
    <div class="sec-title">Колір та матеріал</div>
    <div class="row"><span class="small">Колір</span><input id="color" type="color" value="#b72828"></div>
    <div class="row"><span class="small">Інтенсивність</span><input id="intensity" type="range" min="0" max="100" value="65"></div>
    <div class="row"><span class="small">Глянець</span><input id="gloss" type="range" min="0" max="100" value="20"></div>

    <div class="sec-title">Перфорація / Візерунки</div>
    <div class="row">
      <select id="pattern">
        <option value="none">Без патерну</option>
        <option value="perforation">Перфорація</option>
        <option value="diamonds">Ромби / шви</option>
        <option value="stitch">Паралельні шви</option>
      </select>
    </div>
    <div class="row"><span class="small">Сила патерну</span><input id="pstrength" type="range" min="0" max="100" value="60"></div>

    <div class="sec-title">Дії</div>
    <div class="row">
      <button id="apply" class="btn accent">Застосувати до деталі</button>
      <button id="save" class="btn">ОК (зберегти приклад)</button>
    </div>
    <div id="saved" class="ok">Збережено ✅</div>
  </div>
</div>

<script>
  // Канваси
  const photo = document.getElementById('photo');
  const render = document.getElementById('render');
  const mask   = document.getElementById('mask');
  const pctx = photo.getContext('2d');
  const rctx = render.getContext('2d');
  const mctx = mask.getContext('2d');

  // UI
  const file = document.getElementById('file');
  const toolRadios = [...document.querySelectorAll('input[name="tool"]')];
  const brush = document.getElementById('brush');
  const tol = document.getElementById('tol');
  const refineBtn = document.getElementById('refine');
  const clearBtn = document.getElementById('clear');
  const showMask = document.getElementById('showMask');

  const color = document.getElementById('color');
  const intensity = document.getElementById('intensity');
  const gloss = document.getElementById('gloss');
  const pattern = document.getElementById('pattern');
  const pstrength = document.getElementById('pstrength');
  const applyBtn = document.getElementById('apply');
  const saveBtn = document.getElementById('save');
  const saved = document.getElementById('saved');

  let hasImage=false, drawing=false, curTool='magic';

  function resizeCanvases(w,h){
    [photo, render, mask].forEach(c=>{ c.width=w; c.height=h; });
    mctx.clearRect(0,0,w,h);
    rctx.clearRect(0,0,w,h);
  }

  // Завантаж фото
  file.addEventListener('change', e=>{
    const f=e.target.files[0]; if(!f) return;
    const url=URL.createObjectURL(f);
    const img=new Image();
    img.onload=()=>{
      let w=img.naturalWidth, h=img.naturalHeight;
      const ms=1400, m=Math.max(w,h);
      if(m>ms){ const s=ms/m; w=Math.round(w*s); h=Math.round(h*s); }
      resizeCanvases(w,h);
      pctx.drawImage(img,0,0,w,h);   // ФОТО малюється тільки тут
      hasImage=true;
      drawPreview();
    };
    img.src=url;
  });

  toolRadios.forEach(r=> r.addEventListener('change', ()=>{ curTool = toolRadios.find(x=>x.checked).value; }));

  function getPos(evt, canvas){
    const rect=canvas.getBoundingClientRect();
    const sx=canvas.width/rect.width, sy=canvas.height/rect.height;
    return { x:Math.round((evt.clientX-rect.left)*sx), y:Math.round((evt.clientY-rect.top)*sy) };
  }

  // Малювання маски (білий на невидимому канвасі)
  mask.addEventListener('pointerdown', e=>{
    if(!hasImage) return;
    const pos=getPos(e, mask);
    if(curTool==='magic'){ magicFillAt(pos.x,pos.y,parseInt(tol.value,10)).then(drawPreview); return; }
    drawing=true; drawDot(pos.x,pos.y); drawPreview();
  });
  mask.addEventListener('pointermove', e=>{
    if(!drawing||!hasImage) return;
    const pos=getPos(e, mask); drawDot(pos.x,pos.y); drawPreview();
  });
  ['pointerup','pointerleave','pointercancel'].forEach(ev=> mask.addEventListener(ev, ()=>{ drawing=false; }));

  function drawDot(x,y){
    const b=parseInt(brush.value,10);
    mctx.globalCompositeOperation=(curTool==='eraser')?'destination-out':'source-over';
    mctx.fillStyle='rgba(255,255,255,1)';
    mctx.beginPath(); mctx.arc(x,y,b/2,0,Math.PI*2); mctx.fill();
    mctx.globalCompositeOperation='source-over';
  }

  clearBtn.addEventListener('click', ()=>{ mctx.clearRect(0,0,mask.width,mask.height); drawPreview(); });
  showMask.addEventListener('change', drawPreview);

  // Magic Fill (OpenCV floodFill)
  async function magicFillAt(x,y,tolerance=14){
    await window.cvReady;
    const w=photo.width,h=photo.height;
    const src=cv.imread(photo); cv.cvtColor(src,src,cv.COLOR_RGBA2RGB);
    const ffMask=new cv.Mat.zeros(h+2,w+2,cv.CV_8UC1);
    const lo=new cv.Scalar(tolerance,tolerance,tolerance,0);
    const hi=new cv.Scalar(tolerance,tolerance,tolerance,0);
    const dst=new cv.Mat(); src.copyTo(dst);
    cv.floodFill(dst,ffMask,new cv.Point(x,y),new cv.Scalar(255,255,255,255),new cv.Rect(),lo,hi,(4|(255<<8)));
    const region=new cv.Mat(h,w,cv.CV_8UC1);
    for(let r=0;r<h;r++) for(let c=0;c<w;c++) region.ucharPtr(r,c)[0]=ffMask.ucharPtr(r+1,c+1)[0]?255:0;
    const kernel=cv.Mat.ones(3,3,cv.CV_8U); cv.erode(region,region,kernel);
    const mImg=mctx.getImageData(0,0,w,h);
    for(let i=0,j=0;j<region.data.length;i+=4,j++){
      const add=region.data[j], a=mImg.data[i+3];
      mImg.data[i]=255; mImg.data[i+1]=255; mImg.data[i+2]=255; mImg.data[i+3]=Math.max(a,add);
    }
    mctx.putImageData(mImg,0,0);
    src.delete(); dst.delete(); ffMask.delete(); region.delete(); kernel.delete();
  }

  // GrabCut refine
  async function refineMaskClient(){
    await window.cvReady;
    const w=photo.width,h=photo.height;
    const src=cv.imread(photo); cv.cvtColor(src,src,cv.COLOR_RGBA2RGB);
    const maskImg=mctx.getImageData(0,0,w,h);
    const gcMask=new cv.Mat(h,w,cv.CV_8UC1);
    for(let i=0,j=0;j<w*h;i+=4,j++){ const a=maskImg.data[i+3]; gcMask.data[j]=a>0?3:2; }
    const bg=new cv.Mat(), fg=new cv.Mat(); const rect=new cv.Rect(0,0,w,h);
    cv.grabCut(src,gcMask,rect,bg,fg,5,cv.GC_INIT_WITH_MASK);
    const result=new cv.Mat(h,w,cv.CV_8UC1);
    for(let j=0;j<w*h;j++){ const v=gcMask.data[j]; result.data[j]=(v===1||v===3)?255:0; }
    const out=mctx.createImageData(w,h);
    for(let i=0,j=0;j<w*h;i+=4,j++){ out.data[i]=255; out.data[i+1]=255; out.data[i+2]=255; out.data[i+3]=result.data[j]; }
    mctx.putImageData(out,0,0);
    src.delete(); gcMask.delete(); bg.delete(); fg.delete(); result.delete();
    drawPreview();
  }
  document.getElementById('refine').addEventListener('click', ()=>{ if(hasImage) refineMaskClient(); });

  // Накладка (тільки в межах маски)
  function hexToRgb(hex){ const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return m?{r:parseInt(m[1],16),g:parseInt(m[2],16),b:parseInt(m[3],16)}:{r:200,g:0,b:0} }
  function makePatternCanvas(w,h,kind,strength){
    const c=document.createElement('canvas'); c.width=w;c.height=h; const ctx=c.getContext('2d'); ctx.clearRect(0,0,w,h);
    const a=Math.max(0,Math.min(1,strength/100));
    if(kind==='perforation'){
      const step=18; ctx.fillStyle=`rgba(0,0,0,${0.6*a})`;
      for(let y=step/2;y<h;y+=step) for(let x=step/2;x<w;x+=step){ ctx.beginPath(); ctx.arc(x,y,2,0,Math.PI*2); ctx.fill(); }
    }else if(kind==='diamonds'){
      const step=40; ctx.lineWidth=1; ctx.strokeStyle=`rgba(255,255,255,${0.35*a})`;
      for(let i=-h;i<w+h;i+=step){ ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i-h,h); ctx.stroke(); }
      ctx.strokeStyle=`rgba(0,0,0,${0.45*a})`;
      for(let i=0;i<w+h;i+=step){ ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i+h,h); ctx.stroke(); }
    }else if(kind==='stitch'){
      const step=26; ctx.strokeStyle=`rgba(255,255,255,${0.35*a})`; ctx.lineWidth=1.2;
      for(let y=10;y<h;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
      ctx.strokeStyle=`rgba(0,0,0,${0.35*a})`;
      for(let y=10;y<h;y+=step){ ctx.beginPath(); ctx.moveTo(0,y+3); ctx.lineTo(w,y+3); ctx.stroke(); }
    }
    return c;
  }

  function drawPreview(){
    if(!hasImage){ rctx.clearRect(0,0,render.width,render.height); return; }
    const w=render.width,h=render.height;
    rctx.clearRect(0,0,w,h); // ФОТО НЕ малюємо тут — воно вже на #photo

    const base=pctx.getImageData(0,0,w,h);   // оригінал
    const mimg=mctx.getImageData(0,0,w,h);   // альфа маски
    const overlay=rctx.createImageData(w,h); // прозора накладка

    const col=hexToRgb(color.value);
    const k=Math.max(0,Math.min(1,intensity.value/100));

    // кольорова накладка лише всередині маски
    for(let i=0;i<overlay.data.length;i+=4){
      const a=mimg.data[i+3];
      if(a>0){
        const r0=base.data[i], g0=base.data[i+1], b0=base.data[i+2];
        overlay.data[i]   = Math.round((1-k)*r0 + k*col.r);
        overlay.data[i+1] = Math.round((1-k)*g0 + k*col.g);
        overlay.data[i+2] = Math.round((1-k)*b0 + k*col.b);
        overlay.data[i+3] = 255;
      }else{
        overlay.data[i+3] = 0;
      }
    }
    rctx.putImageData(overlay,0,0);

    const glossK=Math.max(0,Math.min(1,gloss.value/100));
    if(glossK>0){
      rctx.globalCompositeOperation="overlay";
      rctx.fillStyle=`rgba(255,255,255,${0.10*glossK})`;
      rctx.fillRect(0,0,w,h);
      rctx.globalCompositeOperation="source-over";
    }

    if(pattern.value!=='none'){
      const pat=makePatternCanvas(w,h,pattern.value,pstrength.value);
      const pimg=pat.getContext('2d').getImageData(0,0,w,h);
      const out=rctx.getImageData(0,0,w,h);
      for(let i=0;i<out.data.length;i+=4){
        if(mimg.data[i+3]>0){
          out.data[i]=pimg.data[i];
          out.data[i+1]=pimg.data[i+1];
          out.data[i+2]=pimg.data[i+2];
          out.data[i+3]=255;
        }
      }
      rctx.putImageData(out,0,0);
    }

    // напівпрозора синя ПІДСВІТКА маски (тільки якщо увімкнено)
    if(showMask.checked){
      const blue=rctx.createImageData(w,h);
      for(let i=0;i<blue.data.length;i+=4){
        blue.data[i]=30; blue.data[i+1]=80; blue.data[i+2]=255;
        blue.data[i+3]=Math.round(mimg.data[i+3]*0.35); // 35% прозорість
      }
      rctx.putImageData(blue,0,0);
    }
  }

  // Живе прев’ю без кнопки «Застосувати»
  [color,intensity,gloss,pattern,pstrength].forEach(el=>{
    el.addEventListener('input', drawPreview);
    el.addEventListener('change', drawPreview);
  });
  document.getElementById('apply').addEventListener('click', drawPreview);

  document.getElementById('save').addEventListener('click', ()=>{
    saved.style.display='inline'; setTimeout(()=>saved.style.display='none',1800);
  });

  (function init(){ resizeCanvases(1200,720); })();
</script>
</body>
</html>
