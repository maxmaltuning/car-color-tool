<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Car Color Tool</title>
  <style>
    :root { --accent:#ff6600; }
    *{box-sizing:border-box}
    body{margin:0;background:#0d0d0d;color:#fff;font-family:Arial, sans-serif}
    .wrap{max-width:1000px;margin:0 auto;padding:16px}
    h1{margin:8px 0 14px;font-size:22px}
    .card{background:#131313;border:1px solid #242424;border-radius:12px;padding:12px}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .btn, input[type="file"]::file-selector-button{
      background:var(--accent);color:#fff;border:none;padding:10px 16px;border-radius:8px;cursor:pointer;font-size:14px
    }
    .btn.ghost{background:#242424}
    .btn:hover, input[type="file"]::file-selector-button:hover{filter:brightness(.95)}
    input[type="color"]{width:44px;height:36px;border:none;background:transparent}
    input[type="range"]{width:160px}
    .label{font-size:13px;opacity:.9}
    .divider{border-color:#232323;margin:10px 0}

    /* Вьюер займає місце; всередині буде точний прямокутник кадру (.frame) */
    .viewer{
      position:relative;width:100%;aspect-ratio:16/9;background:#000;border-radius:10px;
      overflow:hidden;border:2px solid var(--accent);touch-action:none;
    }
    .frame{
      position:absolute; /* розмір і позицію задаємо в JS під фото */
      left:0; top:0; width:100%; height:100%;
    }
    .layer{position:absolute; left:0; top:0; width:100%; height:100%;}

    /* Фото рендеримо як <img> без object-fit; його розміром керуємо в JS */
    #photo{display:block; width:100%; height:100%;}

    /* Колірні шари рівно над фото */
    .tint{mix-blend-mode:color; opacity:0; pointer-events:none}
    .shadow{mix-blend-mode:multiply; opacity:0; pointer-events:none}

    /* Маска — прозора, але активна. Видимість можна вмикати чекбоксом */
    .maskCanvas{background:transparent; opacity:0; cursor:crosshair}

    .hint{font-size:12px;opacity:.7;margin-top:8px}
    .mode{padding:6px 10px;border-radius:8px;background:#242424;display:flex;gap:6px}
    .mode input{accent-color:var(--accent)}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Car Color Tool</h1>

    <div class="card" style="margin-bottom:10px">
      <div class="row">
        <input type="file" id="fileInput" accept="image/*"/>
        <button id="resetBtn"  class="btn">Скинути налаштування</button>
        <button id="clearMask" class="btn ghost">Очистити виділення</button>
        <button id="refineBtn" class="btn">Уточнити маску (Auto)</button>
      </div>

      <hr class="divider">

      <div class="row">
        <span class="label">Колір:</span>
        <input type="color" id="colorPick" value="#ff6600"/>
        <span class="label">Інтенсивність:</span>
        <input type="range" id="strength" min="0" max="100" value="70"/>
        <span id="strengthVal" class="label">70%</span>
        <label class="row" style="gap:6px;margin-left:10px">
          <input type="checkbox" id="keepShadows" checked/>
          <span class="label">Зберегти тіні</span>
        </label>
        <label class="row" style="gap:6px;margin-left:16px">
          <input type="checkbox" id="showMask"/>
          <span class="label">Показати маску</span>
        </label>
      </div>

      <hr class="divider">

      <div class="row">
        <div class="mode">
          <label class="label"><input type="radio" name="tool" value="brush" checked> Пензлик</label>
          <label class="label"><input type="radio" name="tool" value="eraser"> Гумка</label>
        </div>
        <span class="label">Розмір кисті:</span>
        <input type="range" id="brushSize" min="5" max="160" value="36"/>
        <span id="brushVal" class="label">36 px</span>
      </div>
      <div class="hint">Малюй всередині деталі (не по краю). Після цього тисни «Уточнити маску (Auto)».</div>
    </div>

    <!-- Вьюер: всередині .frame — точний прямокутник відображеного фото -->
    <div class="viewer" id="viewer">
      <div class="frame" id="frame">
        <img id="photo" class="layer" alt="Фото"/>
        <div class="tint layer"   id="tint"></div>
        <div class="shadow layer" id="shadow"></div>
        <canvas id="mask" class="maskCanvas layer"></canvas>
      </div>
    </div>
  </div>

  <script>
    const API_URL = "https://car-color-api.onrender.com"; // твій бекенд

    // ЕЛЕМЕНТИ
    const fileInput = document.getElementById('fileInput');
    const resetBtn = document.getElementById('resetBtn');
    const clearMaskBtn = document.getElementById('clearMask');
    const refineBtn = document.getElementById('refineBtn');

    const colorPick = document.getElementById('colorPick');
    const strength = document.getElementById('strength');
    const strengthVal = document.getElementById('strengthVal');
    const keepShadows = document.getElementById('keepShadows');
    const showMask = document.getElementById('showMask');

    const brushSize = document.getElementById('brushSize');
    const brushVal = document.getElementById('brushVal');
    const toolRadios = document.querySelectorAll('input[name="tool"]');

    const viewer = document.getElementById('viewer');
    const frame  = document.getElementById('frame');
    const photo  = document.getElementById('photo');
    const tint   = document.getElementById('tint');
    const shadow = document.getElementById('shadow');
    const maskCanvas = document.getElementById('mask');
    const ctx = maskCanvas.getContext('2d');

    // СТАН
    let hasImage=false, drawing=false, tool='brush';
    // Геометрія відображення фото всередині viewer:
    // видимий прямокутник фото (px) в системі координат viewer
    let imgBox = {x:0, y:0, w:0, h:0};
    // коефіцієнти переходу між дисплеєм і оригіналом
    let scaleX=1, scaleY=1;

    // ЗАВАНТАЖЕННЯ ФОТО
    fileInput.addEventListener('change', ()=>{
      const f=fileInput.files?.[0]; if(!f) return;
      const r=new FileReader();
      r.onload=e=>{
        photo.src = e.target.result;
        hasImage = true;
        photo.onload = () => {
          layoutToImage();
          clearMask();
          applyTint();
        };
      };
      r.readAsDataURL(f);
    });

    // Розрахунок точного прямокутника фото всередині viewer (як object-fit: contain)
    function layoutToImage(){
      const vw = viewer.clientWidth, vh = viewer.clientHeight;
      const iw = photo.naturalWidth, ih = photo.naturalHeight;
      const s = Math.min(vw/iw, vh/ih);
      const w = Math.round(iw*s), h = Math.round(ih*s);
      const x = Math.round((vw - w)/2), y = Math.round((vh - h)/2);
      imgBox = {x,y,w,h};
      scaleX = iw / w;
      scaleY = ih / h;

      // Задати геометрію всім шарам всередині frame
      frame.style.left = x + "px";
      frame.style.top  = y + "px";
      frame.style.width  = w + "px";
      frame.style.height = h + "px";

      // Маска-канвас має той самий розмір
      maskCanvas.width  = w;
      maskCanvas.height = h;

      // Оновити CSS-маску
      updateCssMask();
    }

    // КОЛІР/ІНТЕНСИВНІСТЬ/ТІНІ (лише в межах frame)
    function applyTint(){
      if(!hasImage) return;
      const c = colorPick.value;
      const s = Number(strength.value)/100;
      tint.style.background = c;
      tint.style.opacity = s.toString();
      if (keepShadows.checked){
        shadow.style.background = c;
        shadow.style.opacity = (s*0.35).toString();
      } else shadow.style.opacity = "0";
      updateCssMask();
    }
    colorPick.addEventListener('input', applyTint);
    strength.addEventListener('input', ()=>{strengthVal.textContent=strength.value+"%"; applyTint();});
    keepShadows.addEventListener('change', applyTint);
    showMask.addEventListener('change', ()=>{ maskCanvas.style.opacity = showMask.checked ? '0.4' : '0'; });

    // ІНСТРУМЕНТИ
    toolRadios.forEach(r=>r.addEventListener('change', e=>{ tool = e.target.value; }));
    brushSize.addEventListener('input', ()=>{ brushVal.textContent = brushSize.value + " px"; });

    // МАЛЮВАННЯ МАСКИ (координати відносно frame!)
    const getPos = (evt)=>{
      const rect = frame.getBoundingClientRect(); // не viewer!
      const e = evt.touches ? evt.touches[0] : evt;
      return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };
    };
    const start = (e)=>{
      if(!hasImage) return;
      drawing=true;
      ctx.lineJoin = ctx.lineCap = 'round';
      ctx.lineWidth = Number(brushSize.value);
      if (tool==='brush'){ ctx.globalCompositeOperation = 'source-over'; ctx.strokeStyle = 'white'; }
      else { ctx.globalCompositeOperation = 'destination-out'; ctx.strokeStyle = 'rgba(0,0,0,1)'; }
      const p=getPos(e);
      ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x+0.01,p.y+0.01); ctx.stroke();
      updateCssMask();
    };
    const move = (e)=>{
      if(!drawing || !hasImage) return;
      const p=getPos(e);
      ctx.lineTo(p.x,p.y);
      ctx.stroke();
      updateCssMask();
    };
    const end = ()=>{ drawing=false; ctx.beginPath(); };

    frame.addEventListener('pointerdown', start);
    frame.addEventListener('pointermove', move);
    window.addEventListener('pointerup', end);
    frame.addEventListener('touchstart', (e)=>{ e.preventDefault(); start(e); }, {passive:false});
    frame.addEventListener('touchmove',  (e)=>{ e.preventDefault(); move(e);  }, {passive:false});
    window.addEventListener('touchend', end);

    // CSS-маска для кольорових шарів (маска масштабується рівно з frame)
    function updateCssMask(){
      const url = maskCanvas.toDataURL('image/png');
      [tint, shadow].forEach(el=>{
        el.style.maskImage = `url(${url})`;
        el.style.webkitMaskImage = `url(${url})`;
        el.style.maskSize = '100% 100%';
        el.style.webkitMaskSize = '100% 100%';
      });
    }

    // ОЧИСТИТИ МАСКУ
    function clearMask(){
      ctx.globalCompositeOperation='source-over';
      ctx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
      updateCssMask();
    }
    clearMaskBtn.addEventListener('click', clearMask);

    // СКИНУТИ НАЛАШТУВАННЯ
    resetBtn.addEventListener('click', ()=>{
      if(!hasImage) return;
      colorPick.value="#ff6600";
      strength.value="70"; strengthVal.textContent="70%";
      keepShadows.checked=true;
      showMask.checked=false; maskCanvas.style.opacity='0';
      clearMask();
      tint.style.opacity="0"; shadow.style.opacity="0";
    });

    // --- УТОЧНЕННЯ НА БЕКЕНДІ (ROI у координатах оригіналу) ---
    async function refineMaskOnServer(){
      if(!hasImage){ alert("Завантаж фото спочатку."); return; }

      // 1) Оригінальне фото
      const photoBlob = await (await fetch(photo.src)).blob();

      // 2) Поточна маска
      const maskBlob = await (await fetch(maskCanvas.toDataURL("image/png"))).blob();

      // 3) Обчислюємо ROI в координатах frame, далі -> у координати оригіналу
      const r = ctx.getImageData(0,0,maskCanvas.width,maskCanvas.height).data;
      let minX=Infinity,minY=Infinity,maxX=-1,maxY=-1;
      for(let i=0;i<r.length;i+=4){
        if(r[i+3]>0){
          const idx=i/4, x=idx%maskCanvas.width, y=Math.floor(idx/maskCanvas.width);
          if(x<minX) minX=x; if(y<minY) minY=y;
          if(x>maxX) maxX=x; if(y>maxY) maxY=y;
        }
      }
      if(!isFinite(minX)){ alert("Намалюй грубу область і спробуй знову."); return; }
      const pad=40;
      minX=Math.max(0,minX-pad); minY=Math.max(0,minY-pad);
      maxX=Math.min(maskCanvas.width-1,maxX+pad);
      maxY=Math.min(maskCanvas.height-1,maxY+pad);

      // frame -> оригінал
      const roiX = Math.round(minX * scaleX);
      const roiY = Math.round(minY * scaleY);
      const roiW = Math.round((maxX - minX + 1) * scaleX);
      const roiH = Math.round((maxY - minY + 1) * scaleY);

      const fd = new FormData();
      fd.append("image", photoBlob, "image.png");
      fd.append("mask",  maskBlob,  "mask.png");
      fd.append("x", roiX); fd.append("y", roiY);
      fd.append("w", roiW); fd.append("h", roiH);

      refineBtn.disabled=true; refineBtn.textContent="Працюю...";
      try{
        const res = await fetch(API_URL + "/refine", {method:"POST", body:fd});
        if(!res.ok) throw new Error("Server error");
        const data = await res.json();

        const out = new Image();
        out.onload = ()=>{
          ctx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
          ctx.drawImage(out,0,0,maskCanvas.width,maskCanvas.height);
          updateCssMask();
          refineBtn.disabled=false; refineBtn.textContent="Уточнити маску (Auto)";
        };
        out.src = "data:image/png;base64," + data.mask_png_base64;
      }catch(e){
        console.error(e);
        alert("Не вдалося уточнити маску. Перевір API_URL.");
        refineBtn.disabled=false; refineBtn.textContent="Уточнити маску (Auto)";
      }
    }
    refineBtn.addEventListener('click', refineMaskOnServer);

    // Перераховуємо геометрію при ресайзі
    window.addEventListener('resize', ()=>{ if(hasImage){ layoutToImage(); } });
  </script>
</body>
</html>
