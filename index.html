<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MAXMAL STUDIO — Interior AI (MVP)</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#11141b; --accent:#ff6a00; --text:#e9eef5; --muted:#93a0b4;
      --btn:#1a1f2b; --ok:#11b981; --warn:#ffb020;
    }
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--text);font:14px/1.4 Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial}
    header{display:flex;align-items:center;gap:10px;padding:10px 16px;border-bottom:1px solid #1f2430;background:var(--panel);position:sticky;top:0;z-index:5}
    .logo{display:flex;align-items:center;gap:8px}
    .logo .mark{width:26px;height:26px;border-radius:6px;background:var(--accent);display:grid;place-items:center;color:#000;font-weight:800}
    .wrap{display:grid;grid-template-columns: 1fr 340px; gap:12px; padding:12px; max-width:1400px; margin:0 auto;}
    .left{display:flex;flex-direction:column;gap:10px}
    .toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center;background:var(--panel);padding:8px;border:1px solid #202534;border-radius:10px}
    .toolbar .group{display:flex;gap:6px;align-items:center}
    .toolbar label{color:var(--muted);font-size:12px;margin-right:4px}
    .btn{background:var(--btn);color:var(--text);border:1px solid #232a38;padding:8px 10px;border-radius:8px;cursor:pointer}
    .btn:hover{border-color:#2d3547}
    .btn.primary{background:var(--accent);color:#111}
    .btn.active{outline:2px solid var(--accent);box-shadow:0 0 0 2px #000 inset}
    .slider{width:180px}
    .panel{background:var(--panel);border:1px solid #202534;border-radius:10px;padding:10px}
    .stage{position:relative; display:grid; place-items:center; background:#0b0e13; border:1px dashed #2a3140; border-radius:10px; overflow:hidden; min-height:420px}
    canvas{max-width:100%;height:auto;display:block}
    .hint{color:var(--muted);font-size:12px;margin-top:6px}
    .right .panel{position:sticky;top:60px}
    .colors{display:grid;grid-template-columns:repeat(10, 1fr);gap:6px;margin:8px 0}
    .sw{width:20px;height:20px;border-radius:4px;border:1px solid #0003;cursor:pointer}
    .tip{font-size:12px;color:var(--muted)}
    .status{font-size:12px;color:var(--muted);margin-left:auto}
    .badge{padding:2px 6px;border-radius:999px;font-size:12px}
    .ok{background:#10271f;color:#2fe39a}
    .err{background:#2b1313;color:#ff6b6b}
  </style>
</head>
<body>
<header>
  <div class="logo"><div class="mark">M</div><div><b>MAXMAL STUDIO</b> — Interior AI (MVP)</div></div>
  <div class="status" id="status">Готово</div>
</header>

<div class="wrap">
  <div class="left">
    <!-- TOOLBAR -->
    <div class="toolbar">
      <div class="group">
        <label>Фото:</label>
        <input type="file" id="file" accept="image/*" class="btn"/>
      </div>

      <div class="group">
        <button class="btn" id="btn-auto">Авто-розпізнавання</button>
        <button class="btn" id="btn-magic">Клік (Magic)</button>
        <button class="btn" id="btn-brush">Пензлик</button>
        <button class="btn" id="btn-eraser">Гумка</button>
      </div>

      <div class="group">
        <label>Кисть</label><input id="brushSize" class="slider" type="range" min="6" max="80" value="32">
        <label>Толерантність (Magic)</label><input id="tol" class="slider" type="range" min="2" max="64" value="22">
      </div>

      <div class="group">
        <button class="btn" id="btn-refine">Уточнити маску</button>
        <button class="btn" id="btn-clear">Очистити</button>
        <label><input type="checkbox" id="showMask"> Показати маску</label>
      </div>
    </div>

    <!-- STAGE -->
    <div class="panel stage">
      <canvas id="photo"></canvas>
      <canvas id="mask"></canvas>
    </div>
    <div class="hint">Порада: обери режим <b>Клік (Magic)</b> і клацни по деталі; або намалюй маску пензлем.</div>
  </div>

  <div class="right">
    <div class="panel">
      <h3 style="margin:0 0 6px">Колір</h3>
      <div id="palette" class="colors"></div>
      <input type="color" id="colorPicker" value="#ff5533" style="width:100%;height:36px;border-radius:8px;border:1px solid #202534;background:#0b0e13;color:#fff"/>

      <h3 style="margin:12px 0 6px">Матеріал</h3>
      <select id="material" style="width:100%;height:34px;border-radius:8px;border:1px solid #202534;background:#0b0e13;color:#fff">
        <option value="leather">Шкіра</option>
        <option value="alcantara">Алькантара</option>
        <option value="fabric">Тканина</option>
      </select>

      <h3 style="margin:12px 0 6px">Перфорація</h3>
      <label><input type="checkbox" id="perforated"> Додати перфорацію</label>

      <div style="margin-top:12px">
        <button class="btn primary" id="applyColor">Застосувати колір</button>
      </div>

      <hr style="border-color:#1f2430;margin:12px 0">
      <div class="tip">Маска напівпрозора. Фарбування торкається лише маски.</div>
      <div id="msg" style="margin-top:10px"></div>
    </div>
  </div>
</div>

<script>
/* ===== НАЛАШТУВАННЯ ===== */
const API_URL = 'https://car-color-api.onrender.com'; // <— твій бекенд

/* ===== СТАН ===== */
let toolMode = 'none';          // 'magic' | 'brush' | 'eraser' | 'auto' | 'none'
let img = new Image();
let photoLoaded = false;
let brushSize = 32;
let tol = 22;

const photo = document.getElementById('photo');
const mask  = document.getElementById('mask');
const pctx = photo.getContext('2d');
const mctx = mask.getContext('2d');

const fileInput = document.getElementById('file');
const btnAuto   = document.getElementById('btn-auto');
const btnMagic  = document.getElementById('btn-magic');
const btnBrush  = document.getElementById('btn-brush');
const btnEraser = document.getElementById('btn-eraser');
const btnRefine = document.getElementById('btn-refine');
const btnClear  = document.getElementById('btn-clear');
const showMask  = document.getElementById('showMask');
const statusEl  = document.getElementById('status');
const paletteEl = document.getElementById('palette');
const colorPicker = document.getElementById('colorPicker');
const applyBtn = document.getElementById('applyColor');
const materialSel = document.getElementById('material');
const perfChk = document.getElementById('perforated');

/* ===== УТИЛІТИ ===== */
function setStatus(t){ statusEl.textContent = t; }
function setMode(m){
  toolMode = m;
  [btnAuto,btnMagic,btnBrush,btnEraser].forEach(b=>b.classList.remove('active'));
  if(m==='auto')   btnAuto.classList.add('active');
  if(m==='magic')  btnMagic.classList.add('active');
  if(m==='brush')  btnBrush.classList.add('active');
  if(m==='eraser') btnEraser.classList.add('active');
}
function fitCanvas(w,h){
  photo.width=w; photo.height=h;
  mask.width=w; mask.height=h;
}
function getXY(evt){
  const r = photo.getBoundingClientRect();
  const x = Math.round((evt.clientX - r.left) * (photo.width/r.width));
  const y = Math.round((evt.clientY - r.top)  * (photo.height/r.height));
  return {x,y};
}
function clearMask(){ mctx.clearRect(0,0,mask.width,mask.height); }

/* напівпрозорий показ маски */
function renderMaskPreview(){
  const imgData = mctx.getImageData(0,0,mask.width,mask.height);
  const p = imgData.data;
  for(let i=0;i<p.length;i+=4){
    const a = p[i+3];
    if(a>0){ p[i]=40; p[i+1]=120; p[i+2]=255; p[i+3]=100; } // синя напівпрозора
  }
  mctx.putImageData(imgData,0,0);
}
showMask.addEventListener('change',()=>{
  mctx.globalCompositeOperation='source-over';
  pctx.drawImage(img,0,0,photo.width,photo.height);
  if(showMask.checked) renderMaskPreview(); else { /* нічого */ }
});

/* ===== ЗАВАНТАЖЕННЯ ФОТО ===== */
fileInput.addEventListener('change', (e)=>{
  const f = e.target.files?.[0]; if(!f) return;
  const url = URL.createObjectURL(f);
  img.onload = ()=>{
    fitCanvas(img.width, img.height);
    pctx.drawImage(img,0,0,photo.width,photo.height);
    clearMask();
    photoLoaded = true;
    setStatus('Фото завантажено');
  };
  img.src = url;
});

/* ===== ІНСТРУМЕНТИ ===== */
document.getElementById('brushSize').addEventListener('input', e=> brushSize = +e.target.value);
document.getElementById('tol').addEventListener('input', e=> tol = +e.target.value);

btnAuto .addEventListener('click', ()=>{ setMode('auto'); autoSegment(); });
btnMagic.addEventListener('click', ()=> setMode('magic'));
btnBrush.addEventListener('click', ()=> setMode('brush'));
btnEraser.addEventListener('click', ()=> setMode('eraser'));

btnClear.addEventListener('click', ()=>{ clearMask(); setStatus('Маску очищено'); });
btnRefine.addEventListener('click', refineMask);

photo.addEventListener('click', (e)=>{
  if(toolMode!=='magic') return;
  if(!photoLoaded){ alert('Завантаж спочатку фото'); return; }
  const {x,y} = getXY(e);
  magicAt(x,y);
});

let painting=false;
mask.addEventListener('mousedown', (e)=>{ 
  if(toolMode!=='brush' && toolMode!=='eraser') return;
  painting=true; drawBrush(e);
});
mask.addEventListener('mousemove', drawBrush);
window.addEventListener('mouseup', ()=> painting=false);
function drawBrush(e){
  if(!painting) return;
  const {x,y} = getXY(e);
  mctx.globalCompositeOperation = (toolMode==='eraser')?'destination-out':'source-over';
  mctx.beginPath();
  mctx.arc(x,y,brushSize/2,0,Math.PI*2);
  mctx.fillStyle='rgba(255,255,255,1)';
  mctx.fill();
  if(showMask.checked) renderMaskPreview();
}

/* ===== MAGIC по кліку ===== */
async function magicAt(x,y){
  try{
    setStatus('Magic…');
    // локальний flood-fill у масці (простий), щоб не чекати бекенд
    const imgData = pctx.getImageData(0,0,photo.width,photo.height);
    const out = mctx.getImageData(0,0,mask.width,mask.height);
    floodFill(imgData,out,x,y,tol);
    mctx.putImageData(out,0,0);
    if(showMask.checked) renderMaskPreview();
    setStatus('Готово');
  }catch(err){ console.error(err); setStatus('Помилка Magic'); }
}

/* найпростіший flood-fill у колірному просторі RGB */
function floodFill(src, dst, sx, sy, tolerance){
  const w=src.width,h=src.height;
  const s = src.data, d = dst.data;
  function idx(x,y){return (y*w+x)*4}
  const start = idx(sx,sy);
  const r0=s[start], g0=s[start+1], b0=s[start+2];

  const seen = new Uint8Array(w*h);
  const q=[ [sx,sy] ];
  const tol2 = tolerance*tolerance*3;

  while(q.length){
    const [x,y]=q.pop();
    const i = idx(x,y);
    if(seen[y*w+x]) continue; seen[y*w+x]=1;
    const dr=s[i]-r0, dg=s[i+1]-g0, db=s[i+2]-b0;
    if(dr*dr+dg*dg+db*db <= tol2){
      d[i]=255; d[i+1]=255; d[i+2]=255; d[i+3]=255;
      if(x>0) q.push([x-1,y]);
      if(x<w-1) q.push([x+1,y]);
      if(y>0) q.push([x,y-1]);
      if(y<h-1) q.push([x,y+1]);
    }
  }
}

/* ===== АВТО-РОЗПІЗНАВАННЯ (бекенд) ===== */
async function autoSegment(){
  if(!photoLoaded){ alert('Завантаж фото'); return; }
  setStatus('Авто-розпізнавання…');

  // готуємо PNG фото (⩽ 1280 по довшій стороні для економії)
  const tmp = document.createElement('canvas');
  const tctx = tmp.getContext('2d');
  const maxSide = Math.max(photo.width, photo.height);
  const scale = 1280 / maxSide;
  tmp.width = Math.round(photo.width * Math.min(1,scale));
  tmp.height= Math.round(photo.height* Math.min(1,scale));
  tctx.drawImage(photo,0,0,tmp.width,tmp.height);
  const blob = await new Promise(res => tmp.toBlob(res, 'image/png', 0.95));

  const fd = new FormData();
  fd.append('image', blob, 'image.png');

  try{
    const res = await fetch(API_URL+'/segment', { method:'POST', body:fd });
    if(!res.ok){ setStatus('Помилка бекенда'); return; }
    const data = await res.json();
    // data.masks — список PNG (base64) білих масок
    clearMask();
    for(const b64 of (data.masks||[])){
      const im = await loadImage('data:image/png;base64,'+b64);
      mctx.drawImage(im,0,0,mask.width,mask.height);
    }
    if(showMask.checked) renderMaskPreview();
    setStatus('Готово');
  }catch(e){
    console.error(e); setStatus('Помилка мережі');
  }finally{
    setMode('none');
  }
}

function loadImage(src){
  return new Promise((res,rej)=>{
    const im=new Image(); im.onload=()=>res(im); im.onerror=rej; im.src=src;
  });
}

/* ===== УТОЧНЕННЯ МАСКИ (бекенд) ===== */
async function refineMask(){
  if(!photoLoaded){ alert('Завантаж фото'); return; }
  setStatus('Уточнення…');

  const photoBlob = await new Promise(r=> photo.toBlob(r,'image/png',0.95));
  const maskBlob  = await new Promise(r=> mask.toBlob(r,'image/png',0.95));

  const fd = new FormData();
  fd.append('image', photoBlob, 'image.png');
  fd.append('mask', maskBlob, 'mask.png');

  try{
    const res = await fetch(API_URL+'/refine', { method:'POST', body:fd });
    if(!res.ok){ setStatus('Помилка бекенда'); return; }
    const data = await res.json();
    clearMask();
    const im = await loadImage('data:image/png;base64,'+data.mask_png_base64);
    mctx.drawImage(im,0,0,mask.width,mask.height);
    if(showMask.checked) renderMaskPreview();
    setStatus('Уточнено');
  }catch(e){ console.error(e); setStatus('Помилка мережі'); }
}

/* ===== ФАРБУВАННЯ ЛИШЕ В МАСКІ ===== */
applyBtn.addEventListener('click', ()=>{
  if(!photoLoaded){ alert('Завантаж фото'); return; }
  const color = hexToRgb(colorPicker.value);
  const keepImg = pctx.getImageData(0,0,photo.width,photo.height);
  const m = mctx.getImageData(0,0,mask.width,mask.height);

  const kd = keepImg.data, md = m.data;
  for(let i=0;i<kd.length;i+=4){
    if(md[i+3]>0){ // в межах маски
      // просте тонування
      kd[i]   = (kd[i]*0.3 + color.r*0.7)|0;
      kd[i+1] = (kd[i+1]*0.3 + color.g*0.7)|0;
      kd[i+2] = (kd[i+2]*0.3 + color.b*0.7)|0;
    }
  }
  pctx.putImageData(keepImg,0,0);
});

function hexToRgb(hex){
  const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return {r:parseInt(m[1],16), g:parseInt(m[2],16), b:parseInt(m[3],16)};
}

/* ===== ПАЛІТРА 20 ШТ ===== */
const PALETTE = ['#ff2d2d','#ff6a00','#ffb400','#ffe100','#a6e22e','#33d17a','#2ec4b6','#34a0ff','#1e90ff','#165dff','#7a5cff','#b86bff','#ff6ac1','#ff8fab','#ff9f43','#ffd166','#06d6a0','#118ab2','#073b4c','#ffffff'];
PALETTE.forEach(c=>{
  const sw = document.createElement('div');
  sw.className='sw'; sw.style.background=c;
  sw.onclick=()=>{ colorPicker.value = c; };
  paletteEl.appendChild(sw);
});
</script>
  <script>
(() => {
  // 👉 Налаштування
  const API_URL = "https://car-color-api.onrender.com"; // твій бекенд на Render
  const AUTO_BTN_TEXT = "Авто-розпізнавання";
  const DONE_BTN_TEXT = "Готово";

  // 1) Знаходимо перший canvas із фото (НЕ чіпаємо твій DOM-розклад)
  const baseCanvas = document.querySelector("canvas");
  if (!baseCanvas) { console.warn("AI-seg: base canvas not found"); return; }

  // 2) Обгортаємо його в stack і додаємо зверху накладний canvas для маски
  const wrap = document.createElement("div");
  wrap.style.position = "relative";
  wrap.style.display = "inline-block";
  baseCanvas.parentNode.insertBefore(wrap, baseCanvas);
  wrap.appendChild(baseCanvas);

  const maskCanvas = document.createElement("canvas");
  maskCanvas.width  = baseCanvas.width;
  maskCanvas.height = baseCanvas.height;
  maskCanvas.style.position = "absolute";
  maskCanvas.style.left = "0";
  maskCanvas.style.top = "0";
  maskCanvas.style.pointerEvents = "none"; // малювання вмикаємо тільки в авто-режимі
  wrap.appendChild(maskCanvas);

  const mctx = maskCanvas.getContext("2d");

  // 3) Невеличкий бейдж статусу (нічого не ламає)
  const badge = document.createElement("div");
  Object.assign(badge.style, {
    position:"absolute", right:"8px", top:"8px",
    background:"rgba(255,140,0,.9)", color:"#000",
    padding:"6px 10px", borderRadius:"10px", font:"600 12px/1.2 Arial",
    display:"none", zIndex:10
  });
  wrap.appendChild(badge);
  const showBadge = (t)=>{ badge.textContent=t; badge.style.display="block"; };
  const hideBadge = ()=>{ badge.style.display="none"; };

  // 4) Зручні помічники
  function canvasToPNG(canvas){ return canvas.toDataURL("image/png"); }
  function clearMask(){ mctx.clearRect(0,0,maskCanvas.width,maskCanvas.height); }
  function tintMaskPreview(){
    // Робимо напівпрозорий синій підсвіт маски, але внутрішньо зберігаємо повну маску
    const tmp = document.createElement("canvas");
    tmp.width = maskCanvas.width; tmp.height = maskCanvas.height;
    tmp.getContext("2d").drawImage(maskCanvas,0,0);
    mctx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
    mctx.drawImage(tmp,0,0);
    mctx.globalCompositeOperation = "source-in";
    mctx.fillStyle = "rgba(0,150,255,0.32)";
    mctx.fillRect(0,0,maskCanvas.width,maskCanvas.height);
    mctx.globalCompositeOperation = "source-over";
  }

  // 5) Малювання в авто-режимі
  let autoMode = false, drawing = false, brush = 18, erase = false;

  function enablePaint(){ maskCanvas.style.pointerEvents = "auto"; }
  function disablePaint(){ maskCanvas.style.pointerEvents = "none"; drawing=false; }

  maskCanvas.addEventListener("mousedown", e => {
    if(!autoMode) return;
    drawing = true;
    mctx.globalCompositeOperation = erase ? "destination-out" : "source-over";
    mctx.fillStyle = "#fff";
    mctx.beginPath();
    mctx.arc(e.offsetX, e.offsetY, brush, 0, Math.PI*2);
    mctx.fill();
    tintMaskPreview();
  });
  maskCanvas.addEventListener("mousemove", e => {
    if(!autoMode || !drawing) return;
    mctx.globalCompositeOperation = erase ? "destination-out" : "source-over";
    mctx.beginPath();
    mctx.arc(e.offsetX, e.offsetY, brush, 0, Math.PI*2);
    mctx.fill();
    tintMaskPreview();
  });
  document.addEventListener("mouseup", ()=> drawing=false);

  // 6) Слухаємо кліки по існуючих кнопках за текстом (нічого не міняємо в HTML)
  document.addEventListener("click", async (ev) => {
    const el = ev.target;
    if (el.tagName !== "BUTTON") return;
    const txt = el.textContent.trim();

    // Увімкнути авто-режим
    if (txt.startsWith(AUTO_BTN_TEXT)) {
      autoMode = true;
      enablePaint();
      showBadge("Авто-режим: намалюй грубо по елементу");
    }

    // Готово → надсилаємо на бекенд refine
    if (txt === DONE_BTN_TEXT && autoMode) {
      try {
        showBadge("Відправляю в AI…");
        // 1) Зберігаємо «чисту» маску (без синього тінту)
        // Для цього перевідтворимо маску: білий піксель там, де альфа > 0
        const bin = document.createElement("canvas");
        bin.width = maskCanvas.width; bin.height = maskCanvas.height;
        const bctx = bin.getContext("2d");
        // Відновлюємо із поточного (синього) вигляду білу бінарну маску
        // (працює, бо усю маску ми малювали кругами/ластиком)
        // Беремо дані й робимо threshold по alpha:
        bctx.drawImage(maskCanvas,0,0);
        const imgData = bctx.getImageData(0,0,bin.width,bin.height);
        const d = imgData.data;
        for(let i=0;i<d.length;i+=4){
          const a = d[i+3];
          if (a>10){ d[i]=255; d[i+1]=255; d[i+2]=255; d[i+3]=255; }
          else { d[i]=0; d[i+1]=0; d[i+2]=0; d[i+3]=255; }
        }
        bctx.putImageData(imgData,0,0);

        const imgPNG  = canvasToPNG(baseCanvas);
        const maskPNG = canvasToPNG(bin);

        // 2) Виклик бекенду
        const res = await fetch(API_URL + "/refine", {
          method:"POST",
          headers: { "Content-Type":"application/json" },
          body: JSON.stringify({ image: imgPNG, mask: maskPNG })
        });
        const data = await res.json();

        // 3) Відобразити результат
        // Під різні відповіді: mask_png_b64 або output[0]
        let b64 = data?.mask_png_b64 || (Array.isArray(data?.output) ? data.output[0] : null);
        if(!b64 || typeof b64 !== "string"){
          showBadge("AI: помилка відповіді");
          console.warn("Unexpected refine response:", data);
          return;
        }
        // Якщо прийшла повна dataURL — залишаємо; якщо лише base64 — додаємо префікс
        if (!b64.startsWith("data:")) b64 = "data:image/png;base64," + b64;

        const refImg = new Image();
        refImg.onload = () => {
          // Малюємо відрефайнену маску напівпрозоро
          mctx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
          mctx.drawImage(refImg,0,0,maskCanvas.width,maskCanvas.height);
          tintMaskPreview();
          showBadge("AI маску уточнив");
          setTimeout(hideBadge, 1400);
        };
        refImg.src = b64;

      } catch (e) {
        console.error(e);
        showBadge("AI: мережна помилка");
      } finally {
        autoMode = false;
        disablePaint();
      }
    }
  });

  // 7) Підстраховка: якщо кнопки немає — додамо непомітно,
  // щоб користувач міг увімкнути авто-режим.
  const maybeToolbar = document.querySelector(".toolbar") || baseCanvas.parentElement;
  if (![...document.querySelectorAll("button")].some(b=>b.textContent.includes(AUTO_BTN_TEXT))){
    const b = document.createElement("button");
    b.textContent = AUTO_BTN_TEXT;
    b.style.margin = "0 8px 8px 0";
    maybeToolbar?.prepend(b);
  }
  if (![...document.querySelectorAll("button")].some(b=>b.textContent.trim()===DONE_BTN_TEXT)){
    const b2 = document.createElement("button");
    b2.textContent = DONE_BTN_TEXT;
    b2.style.margin = "0 8px 8px 0";
    maybeToolbar?.prepend(b2);
  }

  console.log("AI-seg module: ready (non-destructive).");
})();
</script>
  <style>
  /* якщо ці стилі вже є — дубль не завадить */
  #aiMaskCanvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;   /* увімкнемо в коді, коли треба малювати */
    opacity: .35;           /* напівпрозорий перегляд */
    mix-blend-mode: multiply;
    z-index: 9;             /* ПОВЕРХ фото/канвасу */
  }
  .ai-wrap {
    position: relative;
    display: inline-block;
  }
  .ai-badge {
    position: absolute;
    right: 8px;
    top: 8px;
    background: rgba(255,140,0,.95);
    color: #000; font: 600 12px/1.2 system-ui, -apple-system, Arial;
    padding: 6px 10px; border-radius: 10px;
    z-index: 10; display:none;
  }
</style>
  <script>
(() => {
  const API_URL = "https://car-color-api.onrender.com"; // ← твій бекенд
  const AUTO_BTN_TEXT = "Авто-розпізнавання";
  const DONE_BTN_TEXT = "Готово";

  // 0) Знаходимо ваш головний canvas з фото (НЕ створюємо нове фото, не дублюємо)
  // Якщо у вас їх кілька — візьмемо перший видимий.
  const baseCanvas = Array.from(document.querySelectorAll('canvas'))
    .find(c => c.offsetParent !== null);
  if (!baseCanvas) { console.warn('[AI] base canvas not found'); return; }

  // 1) Обгортаємо ТІЛЬКИ якщо ще не обгорнуто
  let wrap = baseCanvas.closest('.ai-wrap');
  if (!wrap) {
    wrap = document.createElement('div');
    wrap.className = 'ai-wrap';
    baseCanvas.parentNode.insertBefore(wrap, baseCanvas);
    wrap.appendChild(baseCanvas);
  }

  // 2) Додаємо ПОВЕРХ один-єдиний шар маски, якщо ще не доданий
  let maskCanvas = document.getElementById('aiMaskCanvas');
  if (!maskCanvas) {
    maskCanvas = document.createElement('canvas');
    maskCanvas.id = 'aiMaskCanvas';
    maskCanvas.width  = baseCanvas.width;
    maskCanvas.height = baseCanvas.height;
    wrap.appendChild(maskCanvas);
  }
  const mctx = maskCanvas.getContext('2d');

  // 3) Значок-статус (не заважає макету)
  let badge = wrap.querySelector('.ai-badge');
  if (!badge) {
    badge = document.createElement('div');
    badge.className = 'ai-badge';
    wrap.appendChild(badge);
  }
  const showBadge = t => { badge.textContent = t; badge.style.display = 'block'; }
  const hideBadge = () => { badge.style.display = 'none'; }

  // 4) Чернеткова кісточка (малювання тільки в авто-режимі)
  let autoMode = false;
  let drawing = false;
  let brushRadius = 18;
  let erase = false; // якщо хочеш гумку — можеш десь перемикати це на true

  function enablePaint()  { maskCanvas.style.pointerEvents = 'auto'; }
  function disablePaint() { maskCanvas.style.pointerEvents = 'none'; drawing=false; }

  maskCanvas.addEventListener('mousedown', e => {
    if (!autoMode) return;
    drawing = true;
    mctx.globalCompositeOperation = erase ? 'destination-out' : 'source-over';
    mctx.fillStyle = '#fff';
    dot(e.offsetX, e.offsetY);
  });
  maskCanvas.addEventListener('mousemove', e => {
    if (!autoMode || !drawing) return;
    mctx.globalCompositeOperation = erase ? 'destination-out' : 'source-over';
    dot(e.offsetX, e.offsetY);
  });
  window.addEventListener('mouseup', ()=> drawing = false);

  function dot(x,y){
    mctx.beginPath();
    mctx.arc(x, y, brushRadius, 0, Math.PI*2);
    mctx.fill();
  }

  // 5) Допоміжні
  function clearMask() { mctx.clearRect(0,0,maskCanvas.width,maskCanvas.height); }
  function canvasToBlob(c) { return new Promise(r => c.toBlob(r, 'image/png', 0.95)); }
  function dataURLToBlob(url) {
    const [meta, b64] = url.split(',');
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) arr[i] = bin.charCodeAt(i);
    const mime = (meta.match(/data:(.*);base64/)||[])[1] || 'image/png';
    return new Blob([arr], {type: mime});
  }

  // 6) Авто-кнопка та “Готово”
  // НІЧОГО не видаляємо: слухаємо існуючі кнопки за текстом;
  // якщо їх немає — тихо додаємо в першу .toolbar
  function ensureButton(text, onClick){
    let btn = Array.from(document.querySelectorAll('button'))
      .find(b => (b.textContent||'').trim() === text);
    if (!btn) {
      const host = document.querySelector('.toolbar') || wrap;
      btn = document.createElement('button');
      btn.textContent = text;
      btn.style.margin = '0 8px 8px 0';
      btn.className = 'btn';
      host.prepend(btn);
    }
    btn.addEventListener('click', onClick);
    return btn;
  }

  ensureButton(AUTO_BTN_TEXT, () => {
    autoMode = true;
    enablePaint();
    showBadge('Авто-режим: помалюй кісточкою по елементу');
  });

  ensureButton(DONE_BTN_TEXT, async () => {
    if (!autoMode) return; // ігноруємо, якщо не в авто-режимі
    try {
      showBadge('Відправляю в AI…');

      // a) ОТРИМАЄМО PNG фото з базового canvas
      //    Якщо у вас рендер не напряму, можеш замінити на свій source:
      const baseDataUrl = baseCanvas.toDataURL('image/png');
      const photoBlob = dataURLToBlob(baseDataUrl);

      // b) БІНАРИЗУЄМО маску (робимо справді біло/чорну без прозорості),
      //    і шлемо як МОЖЛИВОСТІ /refine (multipart, як очікує бекенд FastAPI)
      const bin = document.createElement('canvas');
      bin.width = maskCanvas.width; bin.height = maskCanvas.height;
      const bctx = bin.getContext('2d');
      bctx.drawImage(maskCanvas, 0,0);
      const id = bctx.getImageData(0,0,bin.width,bin.height);
      const p = id.data;
      for (let i=0;i<p.length;i+=4){
        const a = p[i+3];
        if (a>10){ p[i]=255; p[i+1]=255; p[i+2]=255; p[i+3]=255; }
        else     { p[i]=0;   p[i+1]=0;   p[i+2]=0;   p[i+3]=255; }
      }
      bctx.putImageData(id,0,0);
      const maskBlob = await canvasToBlob(bin);

      const fd = new FormData();
      fd.append('image', photoBlob, 'photo.png');
      fd.append('mask',  maskBlob,  'rough_mask.png');

      const res = await fetch(`${API_URL}/refine`, { method:'POST', body: fd });
      if (!res.ok) {
        const t = await res.text();
        showBadge('Помилка бекенду');
        console.error('[AI] /refine error:', res.status, t);
        return;
      }
      const data = await res.json();

      // підтримуємо кілька назв поля: mask_png_base64 або mask_png_b64 або output[0]
      let b64 = data.mask_png_base64 || data.mask_png_b64 ||
                (Array.isArray(data.output) ? data.output[0] : null);

      if (!b64) {
        showBadge('AI: порожня маска');
        console.warn('[AI] unexpected response:', data);
        return;
      }
      if (!b64.startsWith('data:')) b64 = 'data:image/png;base64,' + b64;

      // c) Малюємо отриману УТОЧНЕНУ маску поверх (напівпрозоро)
      const img = new Image();
      img.onload = () => {
        mctx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
        mctx.drawImage(img, 0,0,maskCanvas.width,maskCanvas.height);
        showBadge('AI уточнив маску');
        setTimeout(hideBadge, 1200);
      };
      img.src = b64;

    } catch (e) {
      console.error(e);
      showBadge('AI: мережна помилка');
    } finally {
      // Виходимо з авто-режиму, але НІЧОГО не видаляємо з вашого сайту
      autoMode = false;
      disablePaint();
    }
  });

  // 7) Синхронізуємо розміри при зміні вашого базового canvas
  const ro = new ResizeObserver(()=> {
    maskCanvas.width  = baseCanvas.width;
    maskCanvas.height = baseCanvas.height;
  });
  ro.observe(baseCanvas);

  console.log('[AI] overlay ready — без видалень, лише додано');
})();
</script>
</body>
</html>
